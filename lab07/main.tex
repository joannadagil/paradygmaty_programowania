\documentclass{article}

% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[utf8]{inputenc}
\usepackage[polish]{babel}
\usepackage[T1]{fontenc}

\usepackage{array}
\usepackage{booktabs}

% Set page size and margins
% Replace `letterpaper' with `a4paper' for UK/EU standard size
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}

\usepackage{float}


\usepackage{listings}
\lstset{
  inputencoding=utf8,
  extendedchars=true,
  literate=
    {ą}{{\k{a}}}1
    {ć}{{\'c}}1
    {ę}{{\k{e}}}1
    {ł}{{\l{}}}1
    {ń}{{\'n}}1
    {ó}{{\'o}}1
    {ś}{{\'s}}1
    {ź}{{\'z}}1
    {ż}{{\.z}}1
    {Ą}{{\k{A}}}1
    {Ć}{{\'C}}1
    {Ę}{{\k{E}}}1
    {Ł}{{\L{}}}1
    {Ń}{{\'N}}1
    {Ó}{{\'O}}1
    {Ś}{{\'S}}1
    {Ź}{{\'Z}}1
    {Ż}{{\.Z}}1,
}

\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\usepackage{tikz}
\usetikzlibrary{trees}
\usepackage{forest}
\usetikzlibrary{arrows.meta, shapes.geometric, positioning}


\title{Your Paper}
\author{You}

\begin{document}

\textbf{Tytuł ćwiczenia:} Jednostka 7 - Paradygmat funkcyjny (cz. 2)

\textbf{Autor:} Joanna Dagil

\textbf{Grupa:} TCH-1

\textbf{Data:} 25.11.2025

\section{Cel ćwiczenia}

Celem ćwiczenia jest zapoznanie się z rekurencją i leniwą ewaluacją (przy użyciu generatorów) w paradygmacie funkcyjnym.


\section{Przebieg ćwiczenia}

W tym ćwiczeniu posłużę się językiem Python w edytorze Visual Studio Code. W celu wykonania zadań zapoznaję się z tutorialami, a następnie przechodzę do stworzenia pliku:

\vspace{2ex}

\textbf{123.py}
\lstinputlisting[language=Python]{123.py}

\vspace{2ex}

\textbf{4.py}
\lstinputlisting[language=Python]{4.py}

Programy uruchamiam poleceniem 

\begin{lstlisting}
python {nazwa}.py
\end{lstlisting}




\section{Wyniki działania}

 Dla przykładowych danych

\begin{lstlisting}
-------------- ZADANIE 1 --------------
lista:    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
suma_lista(lista):   55
-------------- ZADANIE 2 --------------
fib_tail(35): 9227465 , time:  8.821487426757812
fib(35):      9227465 , time:  1142055.7498931885
-------------- ZADANIE 3 --------------
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71
-------------- ZADANIE 4 --------------
0 4 64 1156 20736 372100 6677056 119814916 2149991424 38580030724 
\end{lstlisting}


\section{Wnioski}

\subsection{Porównanie rekurencji i iteracji na problemie sumowania listy elementów z zadania 1.}

W podejściu iteracyjnym, aby obliczyć sumę elementów listy, używamy pętli (np. \texttt{for} lub \texttt{while}), która kolejno przechodzi po wszystkich elementach i dodaje je do akumulatora. Taki kod jest bezpośrednio związany z tym, jak komputer wykonuje obliczenia krok po kroku.

W podejściu rekurencyjnym, zastosowanym w funkcji:
\begin{lstlisting}[language=Python]
def suma_lista(lista, i=0):
    if i == len(lista):
        return 0
    return lista[i] + suma_lista(lista, i+1)
\end{lstlisting}
problem jest opisany bardziej deklaratywnie: ``suma listy to pierwszy element plus suma reszty listy''. Funkcja ma wyraźnie wydzielony przypadek bazowy (\texttt{i == len(lista)}) i krok rekurencyjny (wywołanie \texttt{suma\_lista} dla następnego indeksu).

Dla krótkich list oba podejścia zachowują się bardzo podobnie pod względem czasu wykonania. Różnica pojawia się przy dużych strukturach danych: pętle są zwykle bardziej wydajne i nie grozi im przepełnienie stosu, natomiast wersja rekurencyjna zużywa dodatkową pamięć na kolejne ramki stosu i przy bardzo długich listach może zakończyć się błędem. 

W podejściu iteracyjnym możliwa jest również automatyczna optymalizacja pętli przez kompilator.

Natomiast z problemem przepełniania się ramek stosu w podejściu funkcyjnym można sobie poradzić stosując rekurencję ogonową.


Z punktu widzenia paradygmatu funkcyjnego rekurencja jest jednak bardziej naturalna i lepiej oddaje matematyczną definicję problemu.




\subsection{Diagram drzewa wywołań dla rekurencji}

Rozpatrując funkcję \texttt{fib(n)}:
\begin{lstlisting}[language=Python]
def fib(n):
    if n <= 1:
        return n
    return fib(n-1) + fib(n-2)
\end{lstlisting}
drzewo wywołań dla przykładowego \texttt{fib(5)} ma strukturę rozgałęziającą się: w każdym kroku powstają dwa kolejne wywołania (\texttt{fib(n-1)} i \texttt{fib(n-2)}). W efekcie te same argumenty (np. \texttt{fib(2)}, \texttt{fib(3)}) są obliczane wielokrotnie, a liczba wywołań rośnie w przybliżeniu wykładniczo wraz ze wzrostem \texttt{n}. 

Na diagramie drzewa wywołań widać:
\begin{itemize}
    \item wielokrotne pojawianie się tych samych podproblemów,
    \item szybkie ``puchnięcie'' drzewa przy większych \texttt{n},
    \item że przypadki bazowe (\texttt{n == 0} lub \texttt{n == 1}) stanowią liście drzewa.
\end{itemize}

W przeciwieństwie do tego, funkcja \texttt{fib\_tail(n, last, lastlast)} ma tylko jedno wywołanie rekurencyjne w każdym kroku — jej drzewo wywołań jest de facto liniowym łańcuchem. Zmienia to złożoność obliczeniową z wykładniczej na liniową (liczba wywołań jest proporcjonalna do \texttt{n}), chociaż w Pythonie nadal każde wywołanie zajmuje jedno miejsce na stosie, ponieważ nie ma optymalizacji rekurencji ogonowej.


\end{document}
